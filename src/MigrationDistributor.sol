// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/token/ERC20/IERC20.sol";
import "@openzeppelin/access/Ownable.sol";
/**
 * @title MigrationDistributor
 * @notice This contract facilitates the transfer of Base $FWB tokens to users who have locked
 * their tokens in the Migration Manager contract on ETH mainnet
 */
contract MigrationDistributor is Ownable {
    error MigrationDistributor__ZeroAddress_BaseToken();
    error MigrationDistributor__ZeroAddress_MigrationRecorder();
    error MigrationDistributor__ZeroAddress_MigrationProcessor();
    error MigrationDistributor__DepositNotFound(uint256 depositId);
    error MigrationDistributor__TokensAlreadyDistributed(uint64 depositId);
    error MigrationDistributor__TransferFailed(address account, uint256 amount);
    error MigrationDistributor__DepositExists(uint64 depositId);
    error MigrationDistributor__OnlyMigrationRecorder();
    error MigrationDistributor__OnlyMigrationProcessor();
    error MigrationDistributor__ZeroConversionRate();

    event RecordDeposit(uint64 depositId, address recipient, uint256 amount);
    event DistributeTokens(uint64 depositId, address recipient, uint256 amount);

    IERC20 public baseToken;
    address public migrationRecorder;
    address public migrationProcessor;
    uint256 public conversionRate;

    struct Deposit {
        address recipient;
        uint256 amount;
        uint256 baseAmount;
    }

    mapping(uint64 => Deposit) public deposits;
    mapping(address => uint64[]) public userDepositIds;

    modifier onlyMigrationRecorder() {
        if (msg.sender != migrationRecorder) {
            revert MigrationDistributor__OnlyMigrationRecorder();
        }
        _;
    }

    modifier onlyMigrationProcessor() {
        if (msg.sender != migrationProcessor) {
            revert MigrationDistributor__OnlyMigrationProcessor();
        }
        _;
    }

    constructor(uint256 _conversionRate, address _baseToken, address _migrationRecorder, address _migrationProcessor)
        Ownable(msg.sender)
    {
        if (_conversionRate == 0) revert MigrationDistributor__ZeroConversionRate();
        if (_baseToken == address(0)) revert MigrationDistributor__ZeroAddress_BaseToken();
        if (_migrationRecorder == address(0)) revert MigrationDistributor__ZeroAddress_MigrationRecorder();
        if (_migrationProcessor == address(0)) revert MigrationDistributor__ZeroAddress_MigrationProcessor();

        baseToken = IERC20(_baseToken);
        migrationRecorder = _migrationRecorder;
        migrationProcessor = _migrationProcessor;
        conversionRate = _conversionRate;
    }

    /**
     * @notice Adds details of a deposit which has been made on the Migration Manager on mainnet
     * @param depositId Id of the deposit
     * @param recipient Address which will receive the fwb token on base
     * @param amount which was deposited on the Migration Manager
     * @dev The depositId is generated by the Migration Manager
     */
    function recordDeposit(uint64 depositId, address recipient, uint256 amount)
        external
        onlyMigrationRecorder
        returns (uint256)
    {
        if (deposits[depositId].recipient != address(0)) {
            revert MigrationDistributor__DepositExists(depositId);
        }

        deposits[depositId] = Deposit({
            recipient: recipient,
            amount: amount,
            baseAmount: 0 /* baseAmount will be updated when distribution is complete */
        });
        userDepositIds[recipient].push(depositId);
        emit RecordDeposit(depositId, recipient, amount);
        return depositId;
    }

    /**
     * @notice Processes the deposit by distributing FWB tokens to the receiving address
     * @param depositId Id of the deposit
     */
    function distributeTokens(uint64 depositId) external onlyMigrationProcessor {
        Deposit memory deposit = deposits[depositId];
        if (deposit.recipient == address(0)) {
            revert MigrationDistributor__DepositNotFound(depositId);
        }

        if (deposit.baseAmount > 0) {
            revert MigrationDistributor__TokensAlreadyDistributed(depositId);
        }

        uint256 baseAmount = _getBaseAmount(deposit.amount);

        deposits[depositId].baseAmount = baseAmount;

        if (baseToken.transfer(deposit.recipient, baseAmount) == false) {
            revert MigrationDistributor__TransferFailed(deposit.recipient, baseAmount);
        }

        emit DistributeTokens(depositId, deposit.recipient, baseAmount);
    }

    /**
     * @notice Fetches Deposit details
     * @param depositId Id of the deposit
     */
    function getDeposit(uint64 depositId) external view returns (Deposit memory) {
        Deposit memory deposit = deposits[depositId];
        return deposit;
    }

    function changeMigrationRecorder(address newMigrationRecorder) external onlyOwner {
        migrationRecorder = newMigrationRecorder;
    }

    function changeMigrationProcessor(address newMigrationProcessor) external onlyOwner {
        migrationProcessor = newMigrationProcessor;
    }

    function getBaseAmount(uint256 amount) external view returns (uint256) {
        return _getBaseAmount(amount);
    }

    function _getBaseAmount(uint256 amount) private view returns (uint256) {
        return amount * conversionRate;
    }

    function isProcessed(uint64 depositId) external view returns (bool) {
        return deposits[depositId].baseAmount > 0;
    }
}
