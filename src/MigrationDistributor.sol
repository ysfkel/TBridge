// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/token/ERC20/IERC20.sol";
import "@openzeppelin/access/Ownable.sol";
/**
 * @title MigrationDistributor
 * @notice This contract facilitates the transfer of Base $FWB tokens to users who have locked
 * their tokens in the Migration Manager contract on ETH mainnet
 */
contract MigrationDistributor is Ownable {
    
    struct Deposit {
        address recipient;
        uint256 amount;
        uint256 baseAmount;
        uint256 timestamp;
    }

    struct DepositStatus { 
       uint64 depositId;
       bool isProcessed;
    }

    error MigrationDistributor__ZeroAddress_BaseToken();
    error MigrationDistributor__ZeroAddress_MigrationRecorder();
    error MigrationDistributor__ZeroAddress_MigrationProcessor();
    error MigrationDistributor__DepositNotFound(uint64 depositId);
    error MigrationDistributor__TokensAlreadyDistributed(uint64 depositId);
    error MigrationDistributor__TransferFailed(address account, uint256 amount);
    error MigrationDistributor__DepositExists(uint64 depositId);
    error MigrationDistributor__OnlyMigrationRecorder();
    error MigrationDistributor__OnlyMigrationProcessor();
    error MigrationDistributor__ZeroConversionRate();
    error MigrationDistributor__TransferDelayNotElapsed(uint64 depositId);

    event RecordDeposit(uint64 depositId, address recipient, uint256 amount);
    event DistributeTokens(uint64 depositId, address recipient, uint256 amount);
    event SetTransferDelay(uint256 transferDelay);
    event SetMigrationRecorder(address migrationRecorder);
    event SetMigrationProcessor(address migrationProcessor);

    uint256 public conversionRate;
    uint256 public transferDelay;
    address public migrationRecorder;
    address public migrationProcessor;
    IERC20 public baseToken;
    // depositStatuses will be used by the relayer to track unprocessed deposits
    DepositStatus[] depositStatuses;
    mapping(uint64 => Deposit) public deposits;
    mapping(address => uint64[]) public userDepositIds;
    // depositStatusIndexes will track array index of depositStatuse array for quick retrieval inorder to avoid looping
    mapping(uint64 depositId => uint256 statusIndex) depositStatusIndexes; 

    modifier onlyMigrationRecorder() {
        if (msg.sender != migrationRecorder) {
            revert MigrationDistributor__OnlyMigrationRecorder();
        }
        _;
    }

    modifier onlyMigrationProcessor() {
        if (msg.sender != migrationProcessor) {
            revert MigrationDistributor__OnlyMigrationProcessor();
        }
        _;
    }

    constructor(uint256 _conversionRate, uint256 _transferDelay, address _baseToken, address _migrationRecorder, address _migrationProcessor)
        Ownable(msg.sender)
    {
        if (_conversionRate == 0) revert MigrationDistributor__ZeroConversionRate();
        if (_baseToken == address(0)) revert MigrationDistributor__ZeroAddress_BaseToken();
        if (_migrationRecorder == address(0)) revert MigrationDistributor__ZeroAddress_MigrationRecorder();
        if (_migrationProcessor == address(0)) revert MigrationDistributor__ZeroAddress_MigrationProcessor();

        baseToken = IERC20(_baseToken);
        migrationRecorder = _migrationRecorder;
        migrationProcessor = _migrationProcessor;
        conversionRate = _conversionRate;
        transferDelay = _transferDelay;
    }

    /**
     * @notice Adds details of a deposit which has been made on the Migration Manager on mainnet
     * @param depositId Id of the deposit
     * @param recipient Address which will receive the fwb token on base
     * @param amount which was deposited on the Migration Manager
     * @dev The depositId is generated by the Migration Manager
     */
    function recordDeposit(uint64 depositId, address recipient, uint256 amount)
        external
        onlyMigrationRecorder
        returns (uint256)
    {
        if (deposits[depositId].recipient != address(0)) {
            revert MigrationDistributor__DepositExists(depositId);
        }

        deposits[depositId] = Deposit({
            recipient: recipient,
            amount: amount,
            baseAmount: 0, /* baseAmount will be updated when distribution is complete */
            timestamp: block.timestamp
        });
        userDepositIds[recipient].push(depositId);
        
        depositStatusIndexes[depositId] = depositStatuses.length;

        // required by relayer to track unprocessed transactions
        depositStatuses.push(DepositStatus({
            depositId: depositId,
            isProcessed: false
        }));

        emit RecordDeposit(depositId, recipient, amount);
        return depositId;
    }

    /**
     * @notice Processes the deposit by distributing FWB tokens to the receiving address
     * @param depositId Id of the deposit
     */
    function distributeTokens(uint64 depositId) external onlyMigrationProcessor {
        Deposit memory deposit = deposits[depositId];

        if(block.timestamp < deposit.timestamp + transferDelay) {
           revert MigrationDistributor__TransferDelayNotElapsed(depositId);
        }

        if (deposit.recipient == address(0)) {
            revert MigrationDistributor__DepositNotFound(depositId);
        }

        if (deposit.baseAmount > 0) {
            revert MigrationDistributor__TokensAlreadyDistributed(depositId);
        }

        uint256 baseAmount = _getBaseAmount(deposit.amount);

        deposits[depositId].baseAmount = baseAmount;
       
        uint256 statusIndex = depositStatusIndexes[depositId];
        
        // required by relayer to track processed deposits
        depositStatuses[statusIndex].isProcessed = true;

        if (baseToken.transfer(deposit.recipient, baseAmount) == false) {
            revert MigrationDistributor__TransferFailed(deposit.recipient, baseAmount);
        }

        emit DistributeTokens(depositId, deposit.recipient, baseAmount);
    }

     /**
      * @notice sets transfer delay
      * @param _transferDelay time delay in seconds before transfer
      */
    function setTransferDelay(uint256 _transferDelay) external onlyOwner() {
        transferDelay = _transferDelay;
        emit SetTransferDelay(_transferDelay);
    }
    
    /**
     * @notice sets _migrationRecorder
     * @param _migrationRecorder address of _migrationRecorder
     */
    function setMigrationRecorder(address _migrationRecorder) external onlyOwner {
        migrationRecorder = _migrationRecorder;
        emit SetMigrationRecorder(_migrationRecorder);
    }
    
    /**
     * @notice sets the address of _migrationProcessor
     * @param _migrationProcessor address of _migrationProcessor
     */
    function setMigrationProcessor(address _migrationProcessor) external onlyOwner {
        migrationProcessor = _migrationProcessor;
        emit SetMigrationProcessor(_migrationProcessor);
    }

    /**
     * @notice Fetches Deposit details
     * @param depositId Id of the deposit
     */
    function getDeposit(uint64 depositId) external view returns (Deposit memory) {
        Deposit memory deposit = deposits[depositId];
        return deposit;
    }

    function getBaseAmount(uint256 amount) external view returns (uint256) {
        return _getBaseAmount(amount);
    }

    function _getBaseAmount(uint256 amount) private view returns (uint256) {
        return amount * conversionRate;
    }

    function isProcessed(uint64 depositId) external view returns (bool) {
        return deposits[depositId].baseAmount > 0;
    }

    function getDepositStatuses() external view returns(DepositStatus[] memory) {
        return depositStatuses;
    }

    function getDepositStatusIndex(uint64 depositId) external view returns(uint256 statusIndex) { 
        return depositStatusIndexes[depositId];
    }
}
